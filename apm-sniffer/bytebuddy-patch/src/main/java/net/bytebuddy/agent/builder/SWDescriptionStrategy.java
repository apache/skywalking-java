/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package net.bytebuddy.agent.builder;

import net.bytebuddy.description.field.FieldDescription;
import net.bytebuddy.description.field.FieldList;
import net.bytebuddy.description.method.MethodDescription;
import net.bytebuddy.description.method.MethodList;
import net.bytebuddy.description.type.TypeDescription;
import net.bytebuddy.dynamic.TargetType;
import net.bytebuddy.pool.TypePool;
import net.bytebuddy.utility.JavaModule;
import net.bytebuddy.utility.nullability.MaybeNull;

import java.lang.annotation.Annotation;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * A DescriptionStrategy to get the original class description by removing dynamic field and method tokens
 * generated by SkyWalking.
 * Modified from AgentBuilder.DescriptionStrategy.Default.HYBRID.
 */
public class SWDescriptionStrategy implements AgentBuilder.DescriptionStrategy {

    private String nameTrait;

    public SWDescriptionStrategy(String nameTrait) {
        this.nameTrait = nameTrait;
    }

    @Override
    public boolean isLoadedFirst() {
        return true;
    }

    @Override
    public TypeDescription apply(String name,
                                 @MaybeNull Class<?> type,
                                 TypePool typePool,
                                 AgentBuilder.CircularityLock circularityLock,
                                 @MaybeNull ClassLoader classLoader,
                                 @MaybeNull JavaModule module) {
        // from type
        if (type != null) {
            return SimpleTypeDescription.of(type, nameTrait);
        }

        // from type pool
        return typePool.describe(name).resolve();
    }

    static class SimpleTypeDescription extends TypeDescription.ForLoadedType {
        /**
         * A cache of type descriptions for commonly used types to avoid unnecessary allocations.
         */
        private static final Map<Class<?>, TypeDescription> TYPE_CACHE;

        /*
         * Initializes the type cache.
         */
        static {
            TYPE_CACHE = new HashMap<Class<?>, TypeDescription>();
            TYPE_CACHE.put(TargetType.class, new ForLoadedType(TargetType.class));
            TYPE_CACHE.put(Class.class, new ForLoadedType(Class.class));
            TYPE_CACHE.put(Throwable.class, new ForLoadedType(Throwable.class));
            TYPE_CACHE.put(Annotation.class, new ForLoadedType(Annotation.class));
            TYPE_CACHE.put(Object.class, new ForLoadedType(Object.class));
            TYPE_CACHE.put(String.class, new ForLoadedType(String.class));
            TYPE_CACHE.put(Boolean.class, new ForLoadedType(Boolean.class));
            TYPE_CACHE.put(Byte.class, new ForLoadedType(Byte.class));
            TYPE_CACHE.put(Short.class, new ForLoadedType(Short.class));
            TYPE_CACHE.put(Character.class, new ForLoadedType(Character.class));
            TYPE_CACHE.put(Integer.class, new ForLoadedType(Integer.class));
            TYPE_CACHE.put(Long.class, new ForLoadedType(Long.class));
            TYPE_CACHE.put(Float.class, new ForLoadedType(Float.class));
            TYPE_CACHE.put(Double.class, new ForLoadedType(Double.class));
            TYPE_CACHE.put(void.class, new ForLoadedType(void.class));
            TYPE_CACHE.put(boolean.class, new ForLoadedType(boolean.class));
            TYPE_CACHE.put(byte.class, new ForLoadedType(byte.class));
            TYPE_CACHE.put(short.class, new ForLoadedType(short.class));
            TYPE_CACHE.put(char.class, new ForLoadedType(char.class));
            TYPE_CACHE.put(int.class, new ForLoadedType(int.class));
            TYPE_CACHE.put(long.class, new ForLoadedType(long.class));
            TYPE_CACHE.put(float.class, new ForLoadedType(float.class));
            TYPE_CACHE.put(double.class, new ForLoadedType(double.class));
        }

        /**
         * Returns a new immutable type description for a loaded type.
         *
         * @param type The type to be represented by this type description.
         * @return The type description representing the given type.
         */
        public static TypeDescription of(Class<?> type, String nameTrait) {
            TypeDescription typeDescription = TYPE_CACHE.get(type);
            return typeDescription == null
                    ? new SimpleTypeDescription(type, nameTrait)
                    : typeDescription;
        }

        private final String nameTrait;

        public SimpleTypeDescription(Class<?> type, String nameTrait) {
            super(type);
            this.nameTrait = nameTrait;
        }

        @Override
        public FieldList<FieldDescription.InDefinedShape> getDeclaredFields() {
            FieldList<FieldDescription.InDefinedShape> fields = super.getDeclaredFields();
            if (nameTrait == null) {
                return fields;
            }
            // Remove dynamic field tokens generated by SkyWalking
            FieldList.Explicit<FieldDescription.InDefinedShape> newFields = new FieldList.Explicit<>(fields.stream()
                    .filter(f -> !f.getName().contains(nameTrait))
                    .collect(Collectors.toList()));
            return newFields;
        }

        @Override
        public MethodList<MethodDescription.InDefinedShape> getDeclaredMethods() {
            MethodList<MethodDescription.InDefinedShape> declaredMethods = super.getDeclaredMethods();
            if (nameTrait == null) {
                return declaredMethods;
            }
            // Remove dynamic method tokens generated by SkyWalking
            MethodList.Explicit<MethodDescription.InDefinedShape> newMethods = new MethodList.Explicit<>(declaredMethods.stream()
                    .filter(f -> !f.getName().contains(nameTrait))
                    .collect(Collectors.toList()));
            return newMethods;
        }
    }
}
